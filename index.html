<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Visualisation Azimutal & Équatorial avec CesiumJS</title>
  <!-- CesiumJS CDN -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.106/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.106/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      padding: 20px;
      display: flex;
      font-family: sans-serif;
    }
    #controls {
      width: 300px;
      margin-right: 20px;
    }
    #controls input,
    #controls select,
    #controls button {
      width: 100%;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
    #cesiumContainer {
      width: 500px;
      height: 500px;
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h3>Paramètres de pointage</h3>
    <label>Latitude (°):<br><input type="number" id="lat" value="48.8566" step="0.0001"></label>
    <label>Longitude (°):<br><input type="number" id="lon" value="2.3522" step="0.0001"></label>
    <label>Système:<br>
      <select id="coordType">
        <option value="horizontal">Azimutal (Az, Alt)</option>
        <option value="equatorial">Équatorial (RA, Dec)</option>
      </select>
    </label>
    <div id="horizInputs">
      <label>Azimut (°):<br><input type="number" id="az" value="45" step="0.1"></label>
      <label>Altitude (°):<br><input type="number" id="alt" value="30" step="0.1"></label>
    </div>
    <div id="eqInputs" style="display:none">
      <label>RA (h déc.):<br><input type="number" id="ra" value="5.0" step="0.01"></label>
      <label>Dec (°):<br><input type="number" id="dec" value="20.0" step="0.1"></label>
      <label>Date UTC:<br><input type="datetime-local" id="date"></label>
    </div>
    <button id="drawPoint">Tracer point</button>
    <button id="drawGlobal">Axes azimutaux globaux</button>
  </div>
  <div id="cesiumContainer"></div>

  <script>
    // Token Cesium Ion
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3M2EwNmFkZi1iZmM0LTQ2NGItYmI4Ni1kYmNhYTc0ZjRlOGEiLCJpZCI6MzIxNDk0LCJpYXQiOjE3NTI1MzczOTN9.92jF4Cw7YScEADUnsviR0dmZ04rdd_8fzKfJjICyBxk';

    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: Cesium.createWorldTerrain(),
      timeline: false,
      animation: false,
      shouldAnimate: false
    });
    // Désactiver zoom et rotation
    viewer.scene.screenSpaceCameraController.enableZoom = false;
    viewer.scene.screenSpaceCameraController.enableRotate = false;

    // Vue globale sans zoom auto
    viewer.camera.setView({
      destination: Cesium.Rectangle.fromDegrees(-180, -90, 180, 90)
    });

    const ARROW_LENGTH = 10_000_000; // longueur des flèches
    const SURFACE_OFFSET = 100_000;  // décalage au-dessus de la surface

    function toCartesian(lat, lon) {
      return Cesium.Cartesian3.fromDegrees(lon, lat, 0);
    }

    function getLocalFrame(lat, lon) {
      const φ = Cesium.Math.toRadians(lat);
      const λ = Cesium.Math.toRadians(lon);
      const up = Cesium.Cartesian3.normalize(
        Cesium.Cartesian3.fromRadians(λ, φ, 1), new Cesium.Cartesian3()
      );
      const east = Cesium.Cartesian3.normalize(
        new Cesium.Cartesian3(-Math.sin(λ), 0, Math.cos(λ)), new Cesium.Cartesian3()
      );
      const north = Cesium.Cartesian3.normalize(
        Cesium.Cartesian3.cross(up, east, new Cesium.Cartesian3()), new Cesium.Cartesian3()
      );
      return { east, north, up };
    }

    function addArrow(origin, dir, color, length = ARROW_LENGTH) {
      // origine décalée
      const start = Cesium.Cartesian3.add(
        origin,
        Cesium.Cartesian3.multiplyByScalar(dir, SURFACE_OFFSET, new Cesium.Cartesian3()),
        new Cesium.Cartesian3()
      );
      const end = Cesium.Cartesian3.add(
        start,
        Cesium.Cartesian3.multiplyByScalar(dir, length, new Cesium.Cartesian3()),
        new Cesium.Cartesian3()
      );
      viewer.entities.add({
        polyline: { positions: [start, end], width: 4, material: color }
      });
    }

    function gmstHours(date) {
      const jd = date.valueOf() / 86400000 + 2440587.5;
      const d = jd - 2451545.0;
      const gmst = 18.697374558 + 24.06570982441908 * d;
      return (gmst % 24 + 24) % 24;
    }

    function equatorialToHorizontal(raHrs, decDeg, latDeg, lonDeg, date) {
      const ra = raHrs * 15 * Math.PI/180;
      const dec = Cesium.Math.toRadians(decDeg);
      const lst = (gmstHours(date) + lonDeg/15) * 15 * Math.PI/180;
      const ha = lst - ra;
      const φ = Cesium.Math.toRadians(latDeg);
      const sinAlt = Math.sin(φ)*Math.sin(dec) + Math.cos(φ)*Math.cos(dec)*Math.cos(ha);
      const alt = Math.asin(sinAlt);
      let az = Math.atan2(
        -Math.sin(ha),
        Math.tan(dec)*Math.cos(φ) - Math.sin(φ)*Math.cos(ha)
      );
      if (az < 0) az += 2*Math.PI;
      return { az: Cesium.Math.toDegrees(az), alt: Cesium.Math.toDegrees(alt) };
    }

    // UI Handlers
    document.getElementById('coordType').addEventListener('change', e => {
      document.getElementById('horizInputs').style.display = e.target.value === 'horizontal' ? 'block' : 'none';
      document.getElementById('eqInputs').style.display    = e.target.value === 'equatorial' ? 'block' : 'none';
    });

    document.getElementById('drawPoint').addEventListener('click', () => {
      viewer.entities.removeAll();
      drawAt(parseFloat(lat.value), parseFloat(lon.value));
    });

    document.getElementById('drawGlobal').addEventListener('click', () => {
      viewer.entities.removeAll();
      const lats = [-60, -30, 0, 30, 60];
      const lons = [-180, -120, -60, 0, 60, 120, 180];
      lats.forEach(la => lons.forEach(lo => drawAt(la, lo)));
    });

    function drawAt(lat, lon) {
      const P = toCartesian(lat, lon);
      const { east, north, up } = getLocalFrame(lat, lon);
      // axes locaux
      addArrow(P, north, Cesium.Color.RED);
      addArrow(P, east,  Cesium.Color.GREEN);
      addArrow(P, up,    Cesium.Color.BLUE);
      // calcul az/alt
      let az, alt;
      if (coordType.value === 'horizontal') {
        az  = Cesium.Math.toRadians(parseFloat(az.value));
        alt = Cesium.Math.toRadians(parseFloat(alt.value));
      } else {
        const h = equatorialToHorizontal(
          parseFloat(ra.value), parseFloat(dec.value),
          lat, lon,
          date.valueAsDate || new Date()
        );
        az  = Cesium.Math.toRadians(h.az);
        alt = Cesium.Math.toRadians(h.alt);
      }
      // vecteur direction
      const dir = new Cesium.Cartesian3();
      Cesium.Cartesian3.multiplyByScalar(up,   Math.sin(alt), dir);
      const nn = new Cesium.Cartesian3();
      Cesium.Cartesian3.multiplyByScalar(north, Math.cos(alt)*Math.cos(az), nn);
      Cesium.Cartesian3.add(dir, nn, dir);
      const ee = new Cesium.Cartesian3();
      Cesium.Cartesian3.multiplyByScalar(east,  Math.cos(alt)*Math.sin(az), ee);
      Cesium.Cartesian3.add(dir, ee, dir);
      Cesium.Cartesian3.normalize(dir, dir);
      // flèche cible
      addArrow(P, dir, Cesium.Color.YELLOW, ARROW_LENGTH * 1.2);
    }
  </script>
</body>
</html>
